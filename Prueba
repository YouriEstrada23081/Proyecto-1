//******************************************/
// Universidad del Valle de Guatemala
// BE3029 - Electronica Digital 2
// Youri Estrada
// 10/08/2025
// Laboratorio 4 
// MCU: ESP32 dev kit 1.0
//******************************************/
#include <Arduino.h>
#include <stdint.h>
#include <driver/ledc.h>

//******************************************/
// Definiciones
//******************************************/
#define LEDR 27
#define LEDB 26
#define LEDG 24

#define bt1 35
#define servo 13
#define temp 34
unsigned long ts = 0;
unsigned long ts_b3 = 0;
const long d = 300;
int contador = 0;
int valormap=0;
// Banderas y contadores
bool us1 = false;

// Arreglos
const int Servo[5] = {1638, 3277, 4915, 6554, 8192};
int posicion_servo = 0;
// Canales PWM
#define pwmChannel 0
#define pwmChannel1 1
#define pwmChannel2 2
#define pwmChannel3 3

// Frecuencias y ResoluciÃ³n
#define freqPWM 100
#define resPWN 6
#define freqPWM_servo 50
#define resPWM_servo 16

// Prototipos de funciones
void initPWN(void);
void initPWN1(void);
void initPWN2(void);
void initServo(void);

//******************************************/
// Configuracion
//******************************************/
void setup() {
  initPWN();
  initPWN1();
  initPWN2();
  initServo();
  pinMode(bt1, INPUT_PULLDOWN);
  Serial.begin(115200);
}

//******************************************/
// Loop Principal
//******************************************/
void loop() {
  bool b1= digitalRead(bt1);


  if (b1 == true && us1 == false) {
    if ((millis() - ts_b3) > d) {
      contador++;
      if (contador> 1) {
        contador = 0;
      }
      ts_b3 = millis();
    }
  }
  us1 = b1;
  double adcRaw = 0; // Y(0)
  double adcFiltrado = adcRaw; // S(0) = Y(0)
  double alpha = 0.05; // Factor de suavizado (0-1)
  adcRaw = analogRead(temp);
  adcFiltrado = (alpha * adcRaw) + ((1.0 - alpha) * adcFiltrado);
  if (valormap<22){
    posicion_servo=1;
  } else if (valormap>22 && valormap<25){
    posicion_servo=2;
  } else if (valormap>25){
    posicion_servo=3;
  }
  ledcWrite(pwmChannel3, Servo[posicion_servo]);

    switch (posicion_servo) {
      case 0: 
      ledcWrite(pwmChannel2, 0); //led rojo
      ledcWrite(pwmChannel, 0);  //led azul
      ledcWrite(pwmChannel1, 0); //led verde
      break; 
      case 1: 
      ledcWrite(pwmChannel2, 63); 
      ledcWrite(pwmChannel, 0);  
      ledcWrite(pwmChannel1, 0);
      break; 
      case 2:
      ledcWrite(pwmChannel2, 0); 
      ledcWrite(pwmChannel, 0);  
      ledcWrite(pwmChannel1, 63);
      break; 
      case 3:
      ledcWrite(pwmChannel2, 0); 
      ledcWrite(pwmChannel, 63);  
      ledcWrite(pwmChannel1, 0);
      break; 
      case 4: 
      ledcWrite(pwmChannel2, 0); 
      ledcWrite(pwmChannel, 0);  
      ledcWrite(pwmChannel1, 0);
      break; 
    }
  }

//******************************************/
// Otras funciones 
//******************************************/
void initPWN(void) {
  ledcSetup(pwmChannel, freqPWM, resPWN);
  ledcAttachPin(LEDB, pwmChannel);
}
void initPWN1(void) {
  ledcSetup(pwmChannel1, freqPWM, resPWN);
  ledcAttachPin(LEDG, pwmChannel1);
}
void initPWN2(void) {
  ledcSetup(pwmChannel2, freqPWM, resPWN);
  ledcAttachPin(LEDR, pwmChannel2);
}
void initServo(void) {
  ledcSetup(pwmChannel3, freqPWM_servo, resPWM_servo);
  ledcAttachPin(servo, pwmChannel3);
}
